# 给定一个无序的整数数组，找到其中最长上升子序列的长度。

# 说明:
#
# 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
# 你算法的时间复杂度应该为 O(n2) 。
# 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
#




# 用n方是中等，用nlogn就是hard
# 感觉要往前找好几个子序列和子序列之外的数字才能决定当前。
# 如果dp代表长度，这题难在和前边没有直接关系。
# 1,3,2,3,1,4，
#
# 所以思路是，以i结尾的最长上升子序列长度，那么应该有很多“真空”？也不是真空。
# 但是比想象中的复杂和繁琐，要把前边的全比一遍，而且dp本身并没有记录下来，还得去查一下对应的最大字母nums[i]。
# 所以这题比之前的新在，dp不能自洽，你得去查原数组。
#
# 但是感觉还不够啊，你比之前全都大才能插进来？那不对的。1,100,2,3,4,5，怎么办？
# 刚才的说法不对，光是中间比较的，就是这么多。
# dp[i=5]要和dp[j = 0,1，2，3，4]对应的nums[j]都对比一下，如果能比nums[i]大，就是dp[i]+1，最后选最大的。
# 没办法，这题就算优化，也是nlogn，所以有些地方能简化，有些地方不能，比如此处要把0到n-1都比一下，这就省不掉！！！
# 另外一个没摸清的状态点是!!!!!!!!!!!dp[i]是以i结尾的最长子序列的长度!!!!!!!!!!!!!!!!!!!!!!!!!!!!!一直没理解这点，i结尾，i必须要：
# dp[0] = 1,[1]
# dp[1] = 2,[1,3]
# dp[2] = 2,[1,2]
# dp[3] = 3,[1,2,3]
# dp[4] = 1,[1]
# dp[5] = 4,[1,2,3,4]
# 但是这不能完啊，你是以某一个点为结尾的，但是不代表最长啊。
# 这时候估计遍历一遍dp，找到最大值，就是结果了。
# 所以，这题新的点在于，dp存的不是一个最终结果，dp存的是一个结尾点，这很像让这个数组选取n个不同起点来找结果，其实，这一步也是省不掉的。所以，没经验的话自己很难拿捏这些。
# 当然，需要从dp中再比较的，之前三角形的从上到下方法也算一个，不过那个比较的逻辑是二维层面，从内部讲，其实存的已经是这个点的最优路径。


class Solution:
    def lengthOfLIS_dp(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        n = len(nums)
        dp = [0] * n

        dp[0] = 1#with nums[0]
        for i in range(1,n):
            dp[i] = 1
            for j in range(0,i):
                if nums[i] > nums[j] and dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1
        return max(dp)

    # 栈的解法。
    #
    # 重点是数学规律吧，栈中每一个位置对应的都是这个长度的“上升子序列”的最小的最后一位取值，如果满足上升，就不存在1, 1
    # 这种情况。
    # 貌似是对的，你栈底存的是长度为1的，最小值，那么上边压的长度2的，肯定比你大啊，不然不上升。
    # 总之，既然长度为2的上升子序列最大的值是2，那么长度3的子序列，最后一个元素肯定能比2大。


    # 然后就是，如何入栈，每次我都要穷举所有可能的情况，然后比较吗？
#而且，这个数学道理和实际代码又不是直接等价的，代码是一种逐渐替代栈的更新方式
    # 产生误解了，听错了，我以为他说这样得到的stack是这个序列呢，其实不是，每一个位置对应的，只是相应长度最小的尾部数值。
    # 之所以要这样更新，可能就是为了有朝一日，某个值变小了，后边的其他值更有机会入栈吧，这个算法的目标是让尽可能多的数字入栈。所以其实就是动态的更新每一个栈位置的数值，让它变小，让后边的数值更方便入栈：比如：
    # 1, 3, 10, 2, 3, 4，5中，4把10替掉，5才可能进来，5进来，就是最长的。
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        stack = []
        stack.append(nums[0])
        for i in range(1,len(nums)):
            # print('nums[i]:',nums[i])
            if nums[i] > stack[-1]:#先比栈顶，效率可能高一些。528ms和44ms的差距
                stack.append(nums[i])
            else:
                for j in range(len(stack)):#优化的点，这里是遍历stack，如果这是n，用二分查找可以变成logn，总的就是从O(n^2)变成O(nlogn）
                    if nums[i] <= stack[j]:
                        stack[j] = nums[i]
                        break#continue不行，跳出两层循环？感觉i应该回去?其实i不用回去，1,3,5,2中，2替换了3，替出去的3不能再回头来替5，要顺序的。按这么想那就都不对了，2还在5后边呢，凭什么到5前边

        return len(stack)





#
# 示例:
#
nums = [10,9,2,5,3,7,101,18]
# nums = [1,3,2,3,1,4]
# 输出: 4
# 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
sol = Solution()
print('ret:',sol.lengthOfLIS(nums))




